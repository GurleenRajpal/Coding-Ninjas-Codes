// Balika Vadhu- Problem
// Send Feedback
// Anandi and Jagya were getting married again when they have achieved proper age. Dadi Sa invited Alok Nath to do the kanyadaan 
// and give blessings. Alok Nath has 2 blessings. Each bessing is in the form of a string consisting of lowercase charaters(a-z) only. 
// But he can give only one blessing of K length because some priest told him to do so. Thus he decides to generate a blessing using 
// the other two blessings. While doing this he wants to ensure that happiness brought into their life by his blessing is maximum.
// The generated blessing is a common subsequence of length K of the two blessings he has. Happiness of the blessing he generates is 
// calculated by the sum of ASCII values of characters in the blessing and he wants the happiness to be maximum. If he is not able to 
// generate a common subsequence of length K then the happiness is 0 (zero). Alok Nath comes to you and asks you to find the maximum 
// happiness that can be generated by the two blessings he has.
// Input Format:
// First line consists of number of test cases T.
// Each test case consists of two strings b1 (blessing 1),b2 (blessing 2) and an integer K, each of them in separate lines.
// Output Format:
// Output consists of T lines each containing an integer denoting the maximum happiness value that can be generated by the two blessings.
// Constraint:
// 1 <= T <= 50
// 1 <= length(b1) , length(b2) <= 100 
// 1 <= K <= 100
// Sample Input
// 2
// asdf
// asdf
// 3
// anandi
// jagya
// 3
// Sample Output
// 317
// 0
// Explanation
// Output1: Maximum happiness value that can be generated by the two blessings is 317 from the sum of ASCII values of characters in 
// the common subsequence "sdf" of length 3.
// Output2: There is no way to generate a common subsequence of length 3, hence the happiness is 0.

#include<bits/stdc++.h>
using namespace std;

pair<int, int> f(string s1, string s2, int k, pair<int, int>*** dp){
    
    if(s1.empty()|| s2.empty() || k==0){
        pair<int, int> p;
        p.first = 0;
        p.second = 0;
        return p;
    }
    
    int m = s1.length();
    int n = s2.length();
    
    if(dp[m][n][k]!=make_pair(-1, -1)) return dp[m][n][k];
    
    
    if(s1[0]==s2[0]){
        
        pair<int, int> q1 = f(s1.substr(1), s2.substr(1), k-1, dp);
        q1.first = 1 + q1.first;
        q1.second += (int)s1[0];
        
        pair<int, int> q2 = f(s1.substr(1), s2.substr(1), k, dp);
        if(q1.second>q2.second){
            return q1;
        }
        return dp[m][n][k] = q2;
    }
    
    pair<int, int> k1 = f(s1.substr(1), s2, k, dp);
    pair<int, int> k2 = f(s1, s2.substr(1), k, dp);
    
    if(k1.second>k2.second){
        return dp[m][n][k] = k1;
    }
    return dp[m][n][k] = k2;
    
}

int main(){
    
    // write your code here
    int t;
    cin>>t;
    while(t--){
        string s1, s2;
        cin>>s1>>s2;
        int x;
        cin>>x;
        string output = "";
        
        pair<int, int>*** dp = new pair<int, int>** [101];
        for(int i=0; i<=100; i++){
            dp[i] = new pair<int, int>* [101];
            for(int j=0; j<=100; j++){
                dp[i][j] = new pair<int, int> [x+1];
                for(int k=0; k<=x; k++){
                    dp[i][j][k] = make_pair(-1, -1);
                }
            }
        }
        
        
        pair<int, int> ans = f(s1, s2, x, dp);
        int value = 0;
        
        if(ans.first>=x){
            cout<<ans.second<<endl;
        }
        else{
            cout<<0<<endl;
        }
        
         for(int i=0; i<101; i++)
        {
            for(int j=0; j<101; j++)
            {
                delete[]dp[i][j];
            }
            delete []dp[i];
        }
        delete[]dp;
               
    }
    return 0;
}
